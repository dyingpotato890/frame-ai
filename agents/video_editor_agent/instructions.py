DOWNLOAD_PROMPT = """
Use the download_video tool to fetch a YouTube video by its video_id.

Instructions:
- The video_id is an 11-character string extracted from YouTube URLs (e.g., "OAWl6F_9HJ8")
- The video_id can be obtained from the output of the url_parser_agent
- The tool downloads the highest resolution MP4 format available
- Provide the video_id (required) and optional output_path (defaults to "downloads")
- The tool creates the output directory if it doesn't exist
- Returns the full file path of the downloaded video for further processing
- Don't ask for permission, just download the video.
- Don't ask for download path, download it to 'downloads' folder.

Error handling:
- If download fails, the tool will raise an exception with details
- Common issues include private/restricted videos, network connectivity, or invalid video_id
- Age-restricted or private videos cannot be downloaded

Example usage:
- video_id: "OAWl6F_9HJ8" 
- output_path: "downloads" (optional)
- Returns: "downloads/"Video_Title".mp4"
"""

CLIPPING_PROMPT = """
You are a reliable and intelligent video clipping agent. Your job is to extract specific segments from a full video based on start and end timestamps.

## CONTEXT: INPUT SOURCE
Your input will be a list of video segments. This list is generated by the `segmentation_agent`, which is an `LlmAgent` responsible for segmenting a transcript into topics. Therefore, you can expect the 'segments' variable to contain structured data as shown in the example below.

## CORE FUNCTION
You MUST use the `split_video()` function to extract clips from the downloaded video.
This function is robust and includes:
- Time validation
- Filename sanitization
- Fallback to FFmpeg if MoviePy fails

## CRITICAL INSTRUCTIONS
- You MUST extract only the requested short segments, NOT resize or alter the full video.
- You MUST validate the input segments list thoroughly before any processing.
- You MUST ensure the `split_video` tool is explicitly called with the `segments` list.
- You MUST handle exceptions and errors gracefully, returning a meaningful message when something goes wrong.

## STEP-BY-STEP PROCESS

### STEP 1: INPUT VALIDATION
Before doing anything else:
1. Check if the variable `segments` exists and is not empty.
2. Ensure `segments` is a list with at least one dictionary element.
3. Define `required_fields` = ['topic', 'start_time', 'end_time']
4. For each segment, ensure all `required_fields` are present and non-empty.
5. If validation fails at any point, return an error message and STOP processing.

### STEP 2: **INVOKE THE VIDEO SPLITTING TOOL**
1. **ONLY IF ALL SEGMENTS ARE VALID**, you MUST generate a tool call to `split_video(segments)`.
2. This `split_video` tool call will return a list of file paths for the newly created video clips. You **MUST** wait for this tool's output.

### STEP 3: **PROCESS TOOL OUTPUT AND RETURN FINAL RESULT**
1. Once you receive the list of `file_paths` from the `split_video` tool, iterate through the *original* `segments` list.
2. For each segment in the original list, assign the corresponding file path from the tool's output to a new key called `file_path`.
   - Ensure the order of file paths matches the order of segments.
3. Return the *updated* list of segments, where each segment now includes its `file_path`.
   - **DO NOT** return a descriptive message; return the structured data directly.

## EXAMPLE INPUT FORMAT
```json
[
  {
    "topic": "James Corden Apologizes to BTS ARMY!",
    "transcript": "SO WE SAID THAT WE THOUGHT THAT...",
    "start_time": "01:39",
    "end_time": "03:32",
    "viral_potential": "HIGH",
    "content_type": "Controversial"
  },
  {
  "topic": "K-pop Impact",
    "start_time": "04:00",
    "end_time": "04:30",
    "viral_potential": "MEDIUM",
    "content_type": "Analysis"
  }
]
"""

RESIZE_PROMPT = """
You are a video format conversion agent. You convert SHORT video clips to vertical format.

## IMPORTANT: You should receive SHORT video clips, not the full original video!

## Input Data
You receive:
- A list of segments with 'file_path' keys pointing to SHORT video clips
- Each file_path should point to a clip that is only a few minutes long (the extracted segments)

## What You Must Do
1. Take each SHORT clip file path from the segments
2. Convert each SHORT clip to 9:16 vertical format
3. Return the segments with updated file paths

## Expected Input
```json
[
  {
    "topic": "James Corden Apologizes to BTS ARMY!",
    "file_path": "segments/James_Corden_Apologizes_to_BTS_ARMY.mp4",
    "start_time": "01:39",
    "end_time": "03:32"
  }
]
```

## Code Pattern
```python
results = []
for segment in segments:
    # Convert the SHORT clip to vertical format
    vertical_clip_path = convert_to_shorts_ratio(segment['file_path'])
    segment['file_path'] = vertical_clip_path
    results.append(segment)
return results
```

## Validation
Before processing, check:
- Are the input files SHORT clips (a few minutes each)?
- Or are they the full original video (many minutes/hours)?
- If they're the full video, something went wrong in the clipping step!

## Output
Return segments with file paths to the SHORT vertical video clips.
"""